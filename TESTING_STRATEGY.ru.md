[English](./TESTING_STRATEGY.md) | [Español](./TESTING_STRATEGY.es.md) | [Русский](./TESTING_STRATEGY.ru.md)
***
# Официальная Стратегия Тестирования и План Верификации
## 1. Цели и Область
**Цель:** Убедиться, что внедренная автоматизированная система управления версиями и правила защиты веток работают в соответствии с задокументированными процессами, корректно обрабатывают стандартные сценарии и блокируют ошибочные действия.
**Область Тестирования:**
*   Конфигурация защиты веток через GitHub Rulesets.
*   Функциональность **локального** линтинга для коммитов с помощью Husky.
*   Сквозной, двухфазный рабочий процесс `release-please.yml`.
*   Корректность генерации версий, обновлений `CHANGELOG.md` и создания релизов для структуры монорепозитория.
*   Продвинутые сценарии, включая откаты и проверку связи коммита с путем к файлу.
## 2. Роли

*   **"Разработчик":** Выполняет действия в feature-ветках, создает PR в `dev`.
*   **"Релиз-Менеджер":** Выполняет слияние PR, включая продвижение между `dev`, `stg` и `main`.
## 3. Протокол выполнения тестов
### Часть 0: Обязательные предварительные условия для тестовой среды

Эта первоначальная настройка должна быть выполнена перед запуском любых тестовых сценариев, чтобы гарантировать правильную конфигурацию локальной среды.

| ID | Действие | Команды для выполнения | Ожидаемый результат |
| :--- | :--- | :--- | :--- |
| **0.1** | Установка зависимостей и Git-хуков | В корне свежесклонированного репозитория выполнить:<br>`npm install` | 1. Команда завершается успешно.<br>2. В корне проекта созданы директории `node_modules` и `.husky`. |

---
### Часть A: Проверка локальной и серверной защиты
**Цель:** Убедиться, что локальные хуки и серверные Rulesets работают в связке для корректной блокировки/разрешения действий.

| ID | Сценарий | Действия | Ожидаемый результат |
| :--- | :--- | :--- | :--- |
| **A-1** | **Локальная** проверка формата коммита | **1. Негативный тест (без области):**<br> `git commit --allow-empty -m "test: this must fail"` <br><br> **2. Позитивный тест (с валидной областью):**<br> `git commit --allow-empty -m "test(project): this must pass"` | 1. Команда `git commit` **завершается с ошибкой**. В консоли появляется вывод от `commitlint` (`scope may not be empty`). Коммит не создается.<br><br> 2. Команда `git commit` **проходит успешно**. |
| **A-2** | Прямой push в `dev` заблокирован | `git checkout dev && git pull && git commit --allow-empty -m "test(dev): push rejected" && git push` | Команда `git push` **завершается с ошибкой** от сервера (`(protected branch hook declined)`). |
| **A-3** | Проверка гибкости методов слияния в `dev` | Открыть валидный PR в `dev`. Открыть меню слияния. | В меню слияния **ДОСТУПНЫ ВСЕ** опции: "Create a merge commit", "Squash and merge", "Rebase and merge". |
| **A-4** | Принудительное использование "Merge Commit" на `stg`/`main` | Открыть PR из `dev` в `stg`. Открыть меню слияния. | В меню доступен **только "Create a merge commit"**. |
| **A-5** | Блокировка устаревшей ветки на **всех** целевых ветках | 1. Открыть PR в `stg` (или `dev`).<br>2. Перед слиянием, смержить другое изменение в ту же целевую ветку (`stg` или `dev`). | Первый PR теперь **ЗАБЛОКИРОВАН**, и появляется кнопка "Update branch". |

---
### Часть B: Проверка основной логики `release-please`
**Цель:** Проверить полный двухфазный цикл работы автоматизации релизов.

| ID | Сценарий | Действия | Ожидаемый результат |
| :--- | :--- | :--- | :--- |
| **B-1** | Создание Release PR | Продвинуть коммит `fix(payment): ...` до `main`. Убедиться, что коммит изменяет файл **внутри** директории `services/payment/`. | Автоматически создается **новый Pull Request** с заголовком `chore(release): prepare new release`. Он содержит обновления для `CHANGELOG.md`, `release-please-manifest.json` и `version.txt` компонента. |
| **B-2** | Авто-обновление Release PR | 1. Не мержить PR из B-1.<br>2. Продвинуть до `main` еще один коммит `feat(activity): ...`. | **Новый PR не создается.** Существующий Release PR автоматически обновляется новым коммитом от бота, теперь включая изменения для компонента `activity`. |
| **B-3** | Финализация релиза | Смержить обновленный Release PR из B-2 в `main`. | 1. Воркфлоу `release-please` запускается. Джоб `prepare-release-pr` **пропускается**. <br>2. Джоб `finalize-release` **выполняется и завершается успешно**. <br>3. Создаются новые Git-теги (например, `payment-vX.Y.Z`) и соответствующие GitHub-релизы. |
| **B-4** | "Шумоподавление" и Breaking Change | Продвинуть до `main` коммит `feat(project)!: ...`, используя `chore(release): ...` для сообщений мержа при продвижении. | 1. В новом Release PR файл `CHANGELOG.md` **не содержит** никаких записей `chore(release)`. <br> 2. Версия для компонента `project` увеличена на **мажорную** (например, `1.x.x` -> `2.0.0`). |
| **B-5** | Корректная обработка `revert` | 1. Продвинуть до `main` коммит `feat(activity): ...`.<br>2. Сразу после этого продвинуть до `main` коммит `revert(activity): ...`. | В результирующем Release PR: <br>1. Версия компонента `activity` **НЕ изменилась**. <br>2. `CHANGELOG.md` содержит записи и для `feat` в разделе "Features", и для `revert` в новом разделе "Reverts". |

---
### Часть C: Проверка логики привязки коммита к файлам
**Цель:** Доказать, что система защищена от "фантомных" релизов, когда `scope` коммита не соответствует измененным файлам.

| ID | Сценарий | Действия | Ожидаемый результат |
| :--- | :--- | :--- | :--- |
| **C-1** | "Фантомный" коммит для одного компонента вызывает релиз другого | Продвинуть до `main` коммит с сообщением `fix(payment): phantom commit`, где изменение кода сделано в файле **вне** директории `services/payment/` (например, в корне репозитория). | 1. **Создается/обновляется** Release PR.<br>2. В этом PR изменяется версия только для компонента `project` (соответствующего пути `.`).<br>3. Версия для компонента `payment` **НЕ ИЗМЕНЯЕТСЯ**. `release-please` корректно проигнорировал `scope` коммита. |